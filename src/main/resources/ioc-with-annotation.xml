<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd">

  <!--实验15：===========================================================================================================
  通过注解分别创建Dao、Service、Controller★
  spring有四个注解：@controller @Service @Repository @Component
  注解可以随便加：Spring底层不会去验证你的这个组件，但推荐各自层加各自注解；
  使用注解将组件快速的加入到容器中需要几步；
  1)、给要添加的组件上标四个注解的任何一个
  2)、告诉Spring．目动扫描加了注解的组件(依赖context名称空间)
  3)、一定要导入aop包，支持加注解模式(当然因为我们在springboot模式下进行开发，所以不存在这个问题)

  * 加了注解后，通过spring容器获取目标对象的时候，ID默认就是类名首字母小写；
 * 组件的作用域默认是单例；
-->
  <!-- context: component一scan：自动组件扫描 base-package：指定扫描的基础包,
  把基础包及他下面所有的包的所有加了注解的类．自动扫描进IOC容器中: -->
  <!--<context:component-scan base-package="com.atguigu.springlearn"></context:component-scan>-->

  <!--实验16：===========================================================================================================
  使用context:include-filter指定只扫描哪些类，
  默认是全部扫描进来,所以需要加上use-default-filters="false"配置先禁用掉默认加载规则配置才能生效-->
  <!--<context:component-scan base-package="com.atguigu.springlearn" use-default-filters="false">-->
    <!--<context:include-filter type="assignable" expression="Book2Controller"></context:include-filter>-->
  <!--</context:component-scan>-->

  <!--实验17：TODO 没成功
  使用context:exclude-filter指定扫描包时不包含的类
  type="annotation":指定排除规则，按照注解进行排除。标注了指定注解的组件不要；
  type="assignable":排除某个具体的类，按照类进行排除；
  另外三种大多数情况不会使用
  -->
  <!--<context:component-scan base-package="com.atguigu.springlearn">-->
    <!--<context:exclude-filter type="assignable" expression="Book2Controller"></context:exclude-filter>-->
  <!--</context:component-scan>-->

  <!--实验18：===========================================================================================================
  使用@Autowired注解实现根据类型实现自动装配★-->
  <context:component-scan base-package="com.atguigu.springlearn"></context:component-scan>

  <!--实验19：==========================================================================================================
    如果资源类型的bean不止一个，默认根据@Autowired注解标记的成员变量名作为id查找bean，进行装配★
	 *  spring找寻对应组件过程：
	 *  1.先按照类型去容器中查找对应的组件，在这个过程中会将该组件类型+该组件所有子类型都匹配到，
	 *    这就会产生一个问题，例如Book2Service还存在一个子类Book2ServiceExt，那么spring肯定会在容器中同时找到这两个类型，
	 *    这时spring应该匹配哪一个类型去构造对象呢？？？？？
	 *  2.spring在面对在容器中同时找到多个类型的时候，接下来会将变量名作为id继续进行匹配
	 *    (事实上在IDEA中当你在给变量起名字的时候若是spring容器中只有一个类型，那么IDEA允许随便起名字；
	 *     若是容器中存在多个被定义为同类型的bean时，变量名必须满足首字母为对应变量名的小写，若不满足IDEA会直接进行报错，编译不通过
	 *		比如：在本项目中同时存在Book2Service、Book2ServiceExt、Book2ServiceExt2，那么
	 *		@Autowired
			private Book2Service book2ServiceExt
			中Book2Service的变量名就该满足规则，即book2Service、book2ServiceExt或book2Service2，除此之外都会报错)
			实验20：如果根据成员变量名作为id还是找不到bean，可以使用@Qualifier注解明确指定目标bean的id★===========================
   *  但是这又会衍生出一个问题，即当前这个定义好的变量在项目中已经在多处投入使用了，但是这个时候因为某种原因，
	 *  我要更改该变量名来达到使用容器中同属该变量类型的另一个类型的目的，这个时候如果一个一个去更改项目中已经被多处使用的变量名显然是不合适的，
	 *  那么从spring的角度出发应该怎么解决这个问题呢？？？？？
	 *  spring给出的答案是使用@Qualifier("XXX")注解来指定一个名作为spring在容器中进行查找的id，更改掉spring默认使用变量名作为id去容器中寻找的行为；
	 *  但是Qualifier也会面临一个和上述类似的问题，即万一@Qualifier("XXX")中也没有装配上spring容器中对象会发生什么情况？？？？？
	 *  答案是：会报错，而在IDEA中会和直接使用@Autowired一样，若是在@Qualifier("XXX")中命名不满足规则，IDEA会直接报错，编译不通过
-->

  <!--实验21：==========================================================================================================
	 * 在方法的形参位置使用@Qualifier注解
	 * 那么该方法中所有参数都会按照spring自动注入的规则注入进来，
	 * 注意：加了@Autowired的方法会在当前类被创建的时候自动运行！！！！！也就是说加了@Autowired的方法不需要我们手动调用
-->

  <!--实验22：==========================================================================================================
  @Autowired注解的required属性指定某个属性允许不被设置-->
</beans>